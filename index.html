<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Schwarzschild — Black Hole Ray Tracer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Bebas+Neue&family=Rajdhani:wght@300;400;600&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #010204;
  --panel: rgba(4, 9, 18, 0.96);
  --border: rgba(0, 180, 255, 0.1);
  --border-bright: rgba(0, 180, 255, 0.3);
  --accent: #00b8ff;
  --accent-dim: rgba(0,184,255,0.5);
  --hot: #ff5500;
  --warm: #ffaa00;
  --text: rgba(140, 190, 230, 0.75);
  --textb: rgba(200, 230, 255, 0.95);
  --glow: rgba(0, 184, 255, 0.08);
  --glow-strong: rgba(0, 184, 255, 0.18);
}

html, body {
  width: 100%; height: 100%;
  background: var(--bg);
  overflow: hidden;
  user-select: none;
  cursor: default;
}

#app { display: flex; height: 100vh; width: 100vw; }

/* ── VIEWPORT ────────────────────────────────────────────── */
#vp {
  position: relative;
  flex: 1;
  background: #000;
  overflow: hidden;
}

/* Main ray-trace canvas */
#c {
  display: block;
  width: 100%; height: 100%;
  image-rendering: pixelated;
}

/* Post-process overlay canvas */
#overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
}

/* Vignette */
#vignette {
  position: absolute; inset: 0;
  background: radial-gradient(ellipse at center,
    transparent 50%,
    rgba(0,0,0,0.55) 100%);
  pointer-events: none;
  z-index: 4;
}

/* Scan-lines */
#scanlines {
  position: absolute; inset: 0;
  background: repeating-linear-gradient(
    to bottom,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.07) 2px,
    rgba(0, 0, 0, 0.07) 4px
  );
  pointer-events: none;
  z-index: 5;
}

/* HUD top-left */
#hud {
  position: absolute;
  top: 20px; left: 22px;
  pointer-events: none;
  z-index: 10;
}

#hud-title {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 28px;
  letter-spacing: 0.12em;
  color: var(--textb);
  text-shadow:
    0 0 20px rgba(0,184,255,0.6),
    0 0 60px rgba(0,184,255,0.2);
  line-height: 1;
  margin-bottom: 4px;
}

#hud-sub {
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  letter-spacing: 0.22em;
  color: var(--accent);
  opacity: 0.7;
  text-shadow: 0 0 10px var(--accent);
}

/* Status bar */
#status-bar {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 28px;
  background: rgba(0, 10, 25, 0.85);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 20px;
  z-index: 10;
  backdrop-filter: blur(4px);
}

#status-text {
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  letter-spacing: 0.15em;
  color: var(--accent-dim);
  flex: 1;
}

#progress-wrap {
  width: 160px;
  height: 3px;
  background: rgba(0, 184, 255, 0.08);
  border-radius: 2px;
  overflow: hidden;
}

#pf {
  height: 100%;
  width: 0%;
  background: linear-gradient(to right, var(--accent), var(--warm));
  box-shadow: 0 0 6px var(--accent);
  transition: width 0.04s linear;
}

/* Corner decorations */
.corner {
  position: absolute;
  width: 20px; height: 20px;
  pointer-events: none;
  z-index: 10;
}
.corner::before, .corner::after {
  content: '';
  position: absolute;
  background: var(--accent);
  opacity: 0.4;
}
.corner-tl { top: 10px; left: 10px; }
.corner-tl::before { width: 12px; height: 1px; top: 0; left: 0; }
.corner-tl::after  { width: 1px; height: 12px; top: 0; left: 0; }
.corner-tr { top: 10px; right: 10px; }
.corner-tr::before { width: 12px; height: 1px; top: 0; right: 0; }
.corner-tr::after  { width: 1px; height: 12px; top: 0; right: 0; }
.corner-bl { bottom: 36px; left: 10px; }
.corner-bl::before { width: 12px; height: 1px; bottom: 0; left: 0; }
.corner-bl::after  { width: 1px; height: 12px; bottom: 0; left: 0; }
.corner-br { bottom: 36px; right: 10px; }
.corner-br::before { width: 12px; height: 1px; bottom: 0; right: 0; }
.corner-br::after  { width: 1px; height: 12px; bottom: 0; right: 0; }

/* ── SIDEBAR ─────────────────────────────────────────────── */
#sb {
  width: 300px;
  min-width: 268px;
  background: var(--panel);
  border-left: 1px solid var(--border-bright);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
  backdrop-filter: blur(20px);
  position: relative;
}

/* Subtle animated gradient on the border */
#sb::before {
  content: '';
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 1px;
  background: linear-gradient(
    to bottom,
    transparent,
    var(--accent) 20%,
    var(--warm) 50%,
    var(--accent) 80%,
    transparent
  );
  opacity: 0.4;
  animation: borderFlow 6s ease-in-out infinite;
}

@keyframes borderFlow {
  0%, 100% { opacity: 0.2; transform: scaleY(1); }
  50% { opacity: 0.6; transform: scaleY(0.95); }
}

#sb::-webkit-scrollbar { width: 3px; }
#sb::-webkit-scrollbar-track { background: transparent; }
#sb::-webkit-scrollbar-thumb { background: rgba(0,184,255,0.2); border-radius: 2px; }

/* Header */
.sb-header {
  padding: 22px 20px 16px;
  border-bottom: 1px solid var(--border);
  position: relative;
}

.sb-header h1 {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 18px;
  letter-spacing: 0.18em;
  color: var(--textb);
  margin-bottom: 2px;
}

.sb-header p {
  font-family: 'Rajdhani', sans-serif;
  font-size: 10.5px;
  letter-spacing: 0.04em;
  color: var(--text);
  line-height: 1.5;
  font-weight: 300;
}

/* Section */
.sec {
  padding: 14px 20px;
  border-bottom: 1px solid var(--border);
}

.sec-title {
  font-family: 'Share Tech Mono', monospace;
  font-size: 8px;
  letter-spacing: 0.25em;
  color: var(--accent);
  text-transform: uppercase;
  margin-bottom: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  opacity: 0.8;
}

.sec-title::after {
  content: '';
  flex: 1;
  height: 1px;
  background: linear-gradient(to right, var(--accent), transparent);
  opacity: 0.2;
}

/* Control row */
.cr { margin-bottom: 13px; }
.cr:last-child { margin-bottom: 0; }

.cl {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-bottom: 7px;
}

.cl-label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  letter-spacing: 0.06em;
  color: var(--text);
  font-weight: 400;
}

.cl-val {
  font-family: 'Share Tech Mono', monospace;
  font-size: 10px;
  color: var(--accent);
  min-width: 56px;
  text-align: right;
}

/* Slider */
input[type=range] {
  -webkit-appearance: none;
  width: 100%;
  height: 2px;
  background: rgba(0, 184, 255, 0.1);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
  position: relative;
}

input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px; height: 14px;
  border-radius: 50%;
  background: #000;
  border: 2px solid var(--accent);
  box-shadow: 0 0 8px var(--accent), inset 0 0 4px rgba(0,184,255,0.3);
  cursor: pointer;
  transition: transform 0.1s, box-shadow 0.1s;
}

input[type=range]:hover::-webkit-slider-thumb {
  transform: scale(1.35);
  box-shadow: 0 0 14px var(--accent), inset 0 0 6px rgba(0,184,255,0.5);
}

input[type=range]:active::-webkit-slider-thumb {
  background: var(--accent);
}

/* Toggle */
.tr-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 9px;
}
.tr-row:last-child { margin-bottom: 0; }

.tr-label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  letter-spacing: 0.06em;
  color: var(--text);
}

.tog { position: relative; width: 36px; height: 18px; }
.tog input { opacity: 0; width: 0; height: 0; }
.tog-track {
  position: absolute; inset: 0;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(0,184,255,0.15);
  border-radius: 18px;
  cursor: pointer;
  transition: all 0.2s;
}
.tog-track::before {
  content: '';
  position: absolute;
  width: 12px; height: 12px;
  left: 2px; top: 2px;
  background: rgba(140, 190, 230, 0.4);
  border-radius: 50%;
  transition: transform 0.2s, background 0.2s;
}
.tog input:checked + .tog-track {
  background: rgba(0, 184, 255, 0.12);
  border-color: var(--accent);
  box-shadow: 0 0 8px rgba(0,184,255,0.2);
}
.tog input:checked + .tog-track::before {
  transform: translateX(18px);
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent);
}

/* Readout grid */
.rg { display: grid; grid-template-columns: 1fr 1fr; gap: 7px; }
.rc {
  background: rgba(0, 184, 255, 0.02);
  border: 1px solid var(--border);
  padding: 9px 10px;
  border-radius: 2px;
  transition: border-color 0.2s;
}
.rc:hover { border-color: rgba(0,184,255,0.25); }
.rc-label {
  font-family: 'Share Tech Mono', monospace;
  font-size: 7px;
  letter-spacing: 0.15em;
  color: var(--text);
  opacity: 0.5;
  text-transform: uppercase;
  margin-bottom: 4px;
}
.rc-val {
  font-family: 'Share Tech Mono', monospace;
  font-size: 12px;
  color: var(--warm);
  letter-spacing: 0.05em;
}

/* Buttons */
.btn-row {
  display: flex;
  gap: 8px;
  padding: 14px 20px;
}

button {
  flex: 1;
  padding: 11px 8px;
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.15s;
  position: relative;
  overflow: hidden;
}

button::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.04), transparent);
  pointer-events: none;
}

.btn-render {
  background: rgba(0,184,255,0.06);
  border: 1px solid var(--accent);
  color: var(--accent);
}

.btn-render:hover {
  background: rgba(0,184,255,0.15);
  box-shadow: 0 0 20px rgba(0,184,255,0.2), inset 0 0 10px rgba(0,184,255,0.05);
}

.btn-render.rendering {
  animation: renderPulse 1.2s ease-in-out infinite;
  border-color: var(--warm);
  color: var(--warm);
}

@keyframes renderPulse {
  0%, 100% { box-shadow: 0 0 8px rgba(255,170,0,0.3); }
  50% { box-shadow: 0 0 20px rgba(255,170,0,0.5); }
}

.btn-rand {
  background: transparent;
  border: 1px solid rgba(0,184,255,0.2);
  color: var(--text);
}
.btn-rand:hover {
  border-color: rgba(0,184,255,0.5);
  color: var(--textb);
  background: rgba(0,184,255,0.05);
}

/* Legend */
.legend {
  margin-top: auto;
  padding: 12px 20px 16px;
  border-top: 1px solid var(--border);
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  letter-spacing: 0.04em;
  color: var(--text);
  opacity: 0.5;
  line-height: 1.9;
  font-weight: 300;
}
.legend span { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
.leg-blue { background: #7ae; }
.leg-orange { background: #f62; }
.leg-yellow { background: #fa3; }
.leg-black { background: #222; border: 1px solid #444; }
</style>
</head>
<body>
<div id="app">

<!-- ── VIEWPORT ── -->
<div id="vp">
  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>
  <div id="vignette"></div>
  <div id="scanlines"></div>

  <!-- Corner accents -->
  <div class="corner corner-tl"></div>
  <div class="corner corner-tr"></div>
  <div class="corner corner-bl"></div>
  <div class="corner corner-br"></div>

  <!-- HUD -->
  <div id="hud">
    <div id="hud-title">SCHWARZSCHILD</div>
    <div id="hud-sub">NULL GEODESIC RAY TRACER &nbsp;·&nbsp; RK4 INTEGRATION</div>
  </div>

  <!-- Status bar -->
  <div id="status-bar">
    <div id="status-text">READY</div>
    <div id="progress-wrap"><div id="pf"></div></div>
  </div>
</div>

<!-- ── SIDEBAR ── -->
<div id="sb">
  <div class="sb-header">
    <h1>Configuration</h1>
    <p>Schwarzschild metric · Binet equation · Keplerian disk<br>Doppler, gravitational redshift &amp; beaming</p>
  </div>

  <!-- Spacetime -->
  <div class="sec">
    <div class="sec-title">Spacetime</div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Mass (M)</span><span class="cl-val" id="vm">1.00</span></div>
      <input type="range" id="sm" min="0.3" max="3" step="0.05" value="1">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Camera Distance</span><span class="cl-val" id="vd">20 M</span></div>
      <input type="range" id="sd" min="8" max="60" step="0.5" value="20">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Inclination</span><span class="cl-val" id="vi">80°</span></div>
      <input type="range" id="si" min="2" max="89" step="1" value="80">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Field of View</span><span class="cl-val" id="vf">55°</span></div>
      <input type="range" id="sf" min="15" max="110" step="1" value="55">
    </div>
  </div>

  <!-- Disk -->
  <div class="sec">
    <div class="sec-title">Accretion Disk</div>
    <div class="tr-row">
      <span class="tr-label">Show Disk</span>
      <label class="tog"><input type="checkbox" id="td" checked><span class="tog-track"></span></label>
    </div>
    <div class="cr" style="margin-top:10px">
      <div class="cl"><span class="cl-label">Inner Radius</span><span class="cl-val" id="vri">6.0 M</span></div>
      <input type="range" id="sri" min="2.5" max="12" step="0.25" value="6">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Outer Radius</span><span class="cl-val" id="vro">18 M</span></div>
      <input type="range" id="sro" min="8" max="45" step="0.5" value="18">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Brightness</span><span class="cl-val" id="vb">1.0×</span></div>
      <input type="range" id="sbr" min="0.2" max="5" step="0.1" value="1">
    </div>
  </div>

  <!-- Effects -->
  <div class="sec">
    <div class="sec-title">Relativistic Effects</div>
    <div class="tr-row">
      <span class="tr-label">Doppler Shift</span>
      <label class="tog"><input type="checkbox" id="tdop" checked><span class="tog-track"></span></label>
    </div>
    <div class="tr-row">
      <span class="tr-label">Relativistic Beaming</span>
      <label class="tog"><input type="checkbox" id="tbeam" checked><span class="tog-track"></span></label>
    </div>
    <div class="tr-row">
      <span class="tr-label">Gravitational Redshift</span>
      <label class="tog"><input type="checkbox" id="tgrav" checked><span class="tog-track"></span></label>
    </div>
    <div class="tr-row">
      <span class="tr-label">Star Field</span>
      <label class="tog"><input type="checkbox" id="tstars" checked><span class="tog-track"></span></label>
    </div>
    <div class="tr-row">
      <span class="tr-label">Bloom Post-Process</span>
      <label class="tog"><input type="checkbox" id="tbloom" checked><span class="tog-track"></span></label>
    </div>
  </div>

  <!-- Render Quality -->
  <div class="sec">
    <div class="sec-title">Render Quality</div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Integration Steps</span><span class="cl-val" id="vst">800</span></div>
      <input type="range" id="sst" min="150" max="2000" step="50" value="800">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Step Size (Δφ)</span><span class="cl-val" id="vdp">0.016</span></div>
      <input type="range" id="sdp" min="0.004" max="0.04" step="0.001" value="0.016">
    </div>
    <div class="cr">
      <div class="cl"><span class="cl-label">Resolution</span><span class="cl-val" id="vres">1×</span></div>
      <input type="range" id="sres" min="1" max="3" step="1" value="1">
    </div>
  </div>

  <!-- Readouts -->
  <div class="sec">
    <div class="sec-title">Physics Readout</div>
    <div class="rg">
      <div class="rc"><div class="rc-label">Event Horizon</div><div class="rc-val" id="reh">2.00 M</div></div>
      <div class="rc"><div class="rc-label">Photon Sphere</div><div class="rc-val" id="rph">3.00 M</div></div>
      <div class="rc"><div class="rc-label">ISCO</div><div class="rc-val" id="risco">6.00 M</div></div>
      <div class="rc"><div class="rc-label">r_cam / r_s</div><div class="rc-val" id="rcam">10.0×</div></div>
    </div>
  </div>

  <!-- Buttons -->
  <div class="btn-row">
    <button class="btn-render" id="btn-render" onclick="startRender()">▶ &nbsp;RENDER</button>
    <button class="btn-rand" onclick="randomize()">⟳ &nbsp;RAND</button>
  </div>

  <!-- Legend -->
  <div class="legend">
    <span class="leg-blue"></span>Lensed background stars<br>
    <span class="leg-orange"></span>Near-side disk (blueshifted)<br>
    <span class="leg-yellow"></span>Far-side disk (redshifted)<br>
    <span class="leg-black"></span>Event horizon (r ≤ 2M)
  </div>
</div>
</div>

<script>
'use strict';
// ════════════════════════════════════════════════════════════════════
//  SCHWARZSCHILD BLACK HOLE — RAY TRACER
//  Binet null geodesic equation + RK4 + post-process bloom
// ════════════════════════════════════════════════════════════════════

const c      = document.getElementById('c');
const ctx    = c.getContext('2d');
const ov     = document.getElementById('overlay');
const octx2  = ov.getContext('2d');
let W, H, oW, oH, offscr, offCtx;

// ── Stars ─────────────────────────────────────────────────────────
const NS = 1600;
const sAz = new Float32Array(NS), sEl = new Float32Array(NS);
const sB  = new Float32Array(NS), sH  = new Float32Array(NS);
const sSz = new Uint8Array(NS);
for (let i = 0; i < NS; i++) {
  sAz[i] = (Math.random()*2-1) * Math.PI;
  sEl[i] = (Math.random()-0.5) * Math.PI;
  sB[i]  = Math.pow(Math.random(), 0.45);
  sH[i]  = Math.random();
  sSz[i] = Math.random() < 0.06 ? 2 : 1;
}

// ── Resize ────────────────────────────────────────────────────────
function resize() {
  const vp = document.getElementById('vp');
  W = vp.clientWidth; H = vp.clientHeight;
  c.width  = W; c.height  = H;
  ov.width = W; ov.height = H;
  const sc = +g('sres').value || 1;
  oW = Math.max(1, Math.floor(W/sc));
  oH = Math.max(1, Math.floor(H/sc));
  offscr = document.createElement('canvas');
  offscr.width = oW; offscr.height = oH;
  offCtx = offscr.getContext('2d');
}
window.addEventListener('resize', () => { resize(); startRender(); });

// ── Helpers ───────────────────────────────────────────────────────
const g = id => document.getElementById(id);

function params() {
  return {
    M:       +g('sm').value,
    dist:    +g('sd').value,
    incl:    +g('si').value * Math.PI/180,
    fov:     +g('sf').value * Math.PI/180,
    rin:     +g('sri').value,
    rout:    +g('sro').value,
    bright:  +g('sbr').value,
    steps:   +g('sst').value,
    dphi:    +g('sdp').value,
    disk:     g('td').checked,
    doppler:  g('tdop').checked,
    beam:     g('tbeam').checked,
    grav:     g('tgrav').checked,
    stars:    g('tstars').checked,
    bloom:    g('tbloom').checked,
  };
}

function updateReadouts(p) {
  g('reh').textContent   = (2*p.M).toFixed(2)+' M';
  g('rph').textContent   = (3*p.M).toFixed(2)+' M';
  g('risco').textContent = (6*p.M).toFixed(2)+' M';
  g('rcam').textContent  = (p.dist/2).toFixed(1)+'×';
}

// Slider wiring
[
  ['sm','vm',   v=>(+v).toFixed(2)],
  ['sd','vd',   v=>(+v).toFixed(1)+' M'],
  ['si','vi',   v=>v+'°'],
  ['sf','vf',   v=>v+'°'],
  ['sri','vri', v=>(+v).toFixed(2)+' M'],
  ['sro','vro', v=>(+v).toFixed(1)+' M'],
  ['sbr','vb',  v=>(+v).toFixed(1)+'×'],
  ['sst','vst', v=>v],
  ['sdp','vdp', v=>(+v).toFixed(3)],
  ['sres','vres',v=>v+'×'],
].forEach(([id,vid,fmt])=>{
  g(id).addEventListener('input', ()=>{ g(vid).textContent = fmt(g(id).value); });
});
g('sres').addEventListener('input', resize);

// ════════════════════════════════════════════════════════════════════
//  CORE GEODESIC TRACER
// ════════════════════════════════════════════════════════════════════

function traceRay(ox, oy, oz, dx, dy, dz, p) {
  const M   = p.M;
  const rs  = 2*M;
  const rmax = p.dist*M*4 + 100;

  const r0 = Math.sqrt(ox*ox + oy*oy + oz*oz);
  if (r0 < rs) return { hit:'bh' };

  const rx0 = ox/r0, ry0 = oy/r0, rz0 = oz/r0;
  const cosA = -(dx*rx0 + dy*ry0 + dz*rz0);
  const sinA  = Math.sqrt(Math.max(0, 1 - cosA*cosA));

  if (sinA < 1e-5) {
    return cosA > 0
      ? { hit:'bh' }
      : { hit:'sky', az:Math.atan2(dy,dx), el:Math.asin(Math.max(-1,Math.min(1,dz))), phi:0 };
  }

  // Tangential direction (perpendicular to radial, in ray plane)
  const dot = dx*rx0 + dy*ry0 + dz*rz0;
  let tx = dx-dot*rx0, ty = dy-dot*ry0, tz = dz-dot*rz0;
  const tm = Math.sqrt(tx*tx+ty*ty+tz*tz);
  tx/=tm; ty/=tm; tz/=tm;
  const eTx=tx, eTy=ty, eTz=tz;
  const eRz = rz0;

  // Binet ICs
  let u  = 1/r0;
  let du = -(1/(r0*r0))*(-r0*cosA/sinA);

  const dPhi = p.dphi;
  const N    = p.steps;
  const binet = u_ => 3*M*u_*u_ - u_;

  let phi = 0;
  let prevPz = r0*eRz;

  for (let i = 0; i < N; i++) {
    // RK4
    const k1u = du,              k1du = binet(u);
    const u2  = u+dPhi*.5*k1u,  du2  = du+dPhi*.5*k1du;
    const k2u = du2,             k2du = binet(u2);
    const u3  = u+dPhi*.5*k2u,  du3  = du+dPhi*.5*k2du;
    const k3u = du3,             k3du = binet(u3);
    const u4  = u+dPhi*k3u,     du4  = du+dPhi*k3du;
    const k4u = du4,             k4du = binet(u4);

    u  += dPhi/6*(k1u+2*k2u+2*k3u+k4u);
    du += dPhi/6*(k1du+2*k2du+2*k3du+k4du);
    phi += dPhi;

    if (!isFinite(u) || u < 0) break;
    const r = 1/u;

    if (r <= rs*1.01) return { hit:'bh' };

    if (r > rmax) {
      const az = Math.atan2(eTy,eTx)*Math.sign(sinA)+phi*0.18;
      const el = Math.asin(Math.max(-1,Math.min(1, eTz*Math.sin(phi)+eRz*Math.cos(phi))));
      return { hit:'sky', az, el, phi };
    }

    if (p.disk) {
      const curPz = r*(Math.cos(phi)*eRz + Math.sin(phi)*eTz);
      if (prevPz*curPz < 0) {
        const t_ = Math.abs(prevPz)/(Math.abs(prevPz)+Math.abs(curPz));
        const cPhi = phi-dPhi*(1-t_);
        const cR   = 1/Math.max(1e-6, u-du*dPhi*(1-t_));
        const rin  = p.rin*M, rout = p.rout*M;
        if (cR >= rin && cR <= rout) {
          return { hit:'disk', r:cR, phi:cPhi, near: prevPz > 0 };
        }
      }
      prevPz = curPz;
    }
  }

  const az = Math.atan2(eTy,eTx)+phi*0.1;
  const el = Math.asin(Math.max(-1,Math.min(1,dz)));
  return { hit:'sky', az, el, phi };
}

// ── Star lookup ───────────────────────────────────────────────────
const STAR_R = 0.036;
function skyPacked(az, el, p) {
  if (!p.stars) return 0;
  let best=0, bH=0;
  for (let i=0; i<NS; i++) {
    const daz = ((az-sAz[i]+Math.PI*3)%(Math.PI*2))-Math.PI;
    const del = el-sEl[i];
    const d   = Math.sqrt(daz*daz+del*del);
    const th  = sSz[i]===2 ? STAR_R*1.6 : STAR_R;
    if (d < th) {
      const v = (1-d/th)*sB[i];
      if (v > best) { best=v; bH=sH[i]; }
    }
  }
  if (best < 0.01) return 0;
  let R,G,B;
  if (bH<.15){R=175;G=205;B=255;}
  else if(bH<.4){R=215;G=225;B=255;}
  else if(bH<.65){R=255;G=255;B=245;}
  else{R=255;G=225;B=165;}
  return (Math.min(255,R*best)<<16)|(Math.min(255,G*best)<<8)|Math.min(255,B*best);
}

// ── Disk color ────────────────────────────────────────────────────
function diskPacked(r, phi, near, p) {
  const M = p.M;
  const rin=p.rin*M, rout=p.rout*M;
  const t = Math.max(1e-3, Math.min(1, (r-rin)/(rout-rin)));

  const temp = Math.pow(t, -0.68);
  const grav  = p.grav ? Math.sqrt(Math.max(0.01, 1-2*M/Math.max(2.05*M,r))) : 1;
  const vorb  = Math.sqrt(M/Math.max(M*1.01, r));

  let dop = 1;
  if (p.doppler) {
    dop = 1/(1+vorb*Math.sin(phi));
    if (p.beam) dop = Math.pow(Math.max(0.01,dop), 3);
    dop = Math.max(0.03, Math.min(7, dop));
  }

  let I = temp*grav*dop*p.bright;
  if (!near) I *= 0.48;

  // Blackbody gradient
  let R,G,B;
  if (t<0.07){R=215;G=235;B=255;}
  else if(t<0.18){const f=(t-0.07)/.11;R=Math.round(215+40*f);G=Math.round(235-25*f);B=Math.round(255-100*f);}
  else if(t<0.38){const f=(t-0.18)/.2;R=255;G=Math.round(210-95*f);B=Math.round(155-115*f);}
  else if(t<0.62){const f=(t-0.38)/.24;R=255;G=Math.round(115-75*f);B=Math.round(40-30*f);}
  else{const f=(t-0.62)/.38;R=Math.round(255-65*f);G=Math.round(40-28*f);B=10;}

  if (p.doppler) {
    if (dop>1.25){const bf=Math.min(1,(dop-1.25)/3.5);B=Math.min(255,B+Math.round(bf*140));G=Math.min(255,G+Math.round(bf*65));}
    else if(dop<0.65){const rf=Math.min(1,(0.65-dop)/.55);G=Math.max(0,G-Math.round(rf*75));B=Math.max(0,B-Math.round(rf*65));}
  }

  return (Math.min(255,Math.max(0,Math.round(R*I)))<<16)|
         (Math.min(255,Math.max(0,Math.round(G*I)))<<8)|
          Math.min(255,Math.max(0,Math.round(B*I)));
}

// ════════════════════════════════════════════════════════════════════
//  POST-PROCESS: BLOOM
//  After raytracing, draw a layered glow on the overlay canvas:
//  1. Disk corona glow (ellipse aligned to disk plane angle)
//  2. Event horizon shadow rim
//  3. Photon sphere ring
// ════════════════════════════════════════════════════════════════════

function drawBloom(p, camX, camY, camR, projW, projH) {
  octx2.clearRect(0, 0, W, H);
  if (!p.bloom) return;

  // Find the screen-space center of the BH (always center of image)
  const cx = W/2, cy = H/2;

  // Estimate the apparent size of the event horizon in pixels
  // Angular diameter ≈ 2 * arctan(r_s / dist) in radians * (pixels/radian)
  const tanFov   = Math.tan(p.fov/2);
  const pixPerRad = (H/2) / tanFov;
  const rs        = 2*p.M;
  const bh_r_px   = Math.max(4, (rs / (p.dist*p.M)) * pixPerRad * 0.5);

  // ── 1. Diffuse disk glow (orange arc) ───────────────────────
  const diskMidR = (p.rin + p.rout) * 0.5 * p.M;
  const diskR_px = Math.max(20, (diskMidR / (p.dist*p.M)) * pixPerRad);
  const incl     = p.incl;  // inclination angle

  // Ellipse: horizontal extent = full disk radius, vertical = compressed by inclination
  const ry_disk = diskR_px * Math.sin(incl);  // compressed in vertical
  const rx_disk = diskR_px;

  // Draw glowing disk corona as ellipse gradient
  for (let layer = 0; layer < 3; layer++) {
    const spread = [2.0, 1.3, 0.7][layer];
    const alpha  = [0.025, 0.04, 0.06][layer];
    octx2.save();
    octx2.translate(cx, cy);
    octx2.scale(1, Math.max(0.05, ry_disk / rx_disk));
    const grad = octx2.createRadialGradient(0,0, bh_r_px, 0,0, rx_disk*spread);
    grad.addColorStop(0,   `rgba(255,120,30,0)`);
    grad.addColorStop(0.35,`rgba(255,100,20,${alpha*1.5})`);
    grad.addColorStop(0.6, `rgba(255,160,40,${alpha})`);
    grad.addColorStop(1,   `rgba(200,80,10,0)`);
    octx2.globalCompositeOperation = 'screen';
    octx2.fillStyle = grad;
    octx2.beginPath();
    octx2.arc(0, 0, rx_disk*spread, 0, Math.PI*2);
    octx2.fill();
    octx2.restore();
  }

  // ── 2. Hot inner ring (ISCO glow) ─────────────────────────────
  const isco_r  = 6*p.M;
  const isco_px = Math.max(8, (isco_r / (p.dist*p.M)) * pixPerRad);
  octx2.save();
  octx2.translate(cx, cy);
  octx2.scale(1, Math.max(0.05, Math.sin(incl)));
  const innerGrad = octx2.createRadialGradient(0,0, isco_px*0.6, 0,0, isco_px*1.4);
  innerGrad.addColorStop(0, 'rgba(255,200,100,0)');
  innerGrad.addColorStop(0.4,'rgba(255,180,60,0.08)');
  innerGrad.addColorStop(0.7,'rgba(255,120,20,0.06)');
  innerGrad.addColorStop(1,  'rgba(255,60,0,0)');
  octx2.globalCompositeOperation = 'screen';
  octx2.fillStyle = innerGrad;
  octx2.beginPath();
  octx2.arc(0, 0, isco_px*1.4, 0, Math.PI*2);
  octx2.fill();
  octx2.restore();

  // ── 3. Event horizon ambient glow ─────────────────────────────
  octx2.save();
  const bhGrad = octx2.createRadialGradient(cx,cy, bh_r_px*0.2, cx,cy, bh_r_px*3.5);
  bhGrad.addColorStop(0,   'rgba(0,0,0,0.6)');
  bhGrad.addColorStop(0.5, 'rgba(0,0,0,0.15)');
  bhGrad.addColorStop(1,   'rgba(0,0,0,0)');
  octx2.globalCompositeOperation = 'multiply';
  octx2.fillStyle = bhGrad;
  octx2.beginPath();
  octx2.arc(cx, cy, bh_r_px*3.5, 0, Math.PI*2);
  octx2.fill();
  octx2.restore();

  // ── 4. Photon sphere ring accent ──────────────────────────────
  const ps_r  = 3*p.M;
  const ps_px = Math.max(6, (ps_r / (p.dist*p.M)) * pixPerRad);
  octx2.save();
  octx2.translate(cx, cy);
  octx2.scale(1, Math.max(0.05, Math.sin(incl)*0.5+0.5));
  octx2.globalCompositeOperation = 'screen';
  octx2.strokeStyle = 'rgba(0,180,255,0.04)';
  octx2.lineWidth   = ps_px * 0.4;
  octx2.shadowBlur  = ps_px * 0.6;
  octx2.shadowColor = 'rgba(0,180,255,0.1)';
  octx2.beginPath();
  octx2.arc(0, 0, ps_px, 0, Math.PI*2);
  octx2.stroke();
  octx2.restore();
}

// ════════════════════════════════════════════════════════════════════
//  MAIN RENDER
// ════════════════════════════════════════════════════════════════════
let rendering = false;

async function startRender() {
  if (rendering) return;
  rendering = true;

  const btn = g('btn-render');
  btn.textContent = '⏹  RENDERING';
  btn.classList.add('rendering');

  resize();
  const p = params();
  updateReadouts(p);
  g('status-text').textContent = 'INITIALISING…';
  g('pf').style.width = '0%';

  const pw=oW, ph=oH;
  const imgData = offCtx.createImageData(pw, ph);
  const data    = imgData.data;

  // Camera
  const M    = p.M;
  const camR = p.dist*M;
  const incl = p.incl;
  const camX =  camR*Math.cos(incl);
  const camY =  camR*Math.sin(incl);
  const camZ = 0;

  const lx=-camX/camR, ly=-camY/camR, lz=0;

  let upX=0, upY=0, upZ=1;
  let rx=ly*upZ-lz*upY, ry=lz*upX-lx*upZ, rz=lx*upY-ly*upX;
  const rm=Math.sqrt(rx*rx+ry*ry+rz*rz); rx/=rm; ry/=rm; rz/=rm;
  let ux=ry*lz-rz*ly, uy=rz*lx-rx*lz, uz=rx*ly-ry*lx;

  const aspect=pw/ph, tanFov=Math.tan(p.fov/2);
  const chunk=Math.max(1,Math.floor(ph/60));

  for (let r0=0; r0<ph; r0+=chunk) {
    for (let py=r0; py<Math.min(ph,r0+chunk); py++) {
      const ny=-((py+.5)/ph-.5)*2;
      for (let px=0; px<pw; px++) {
        const nx=((px+.5)/pw-.5)*2*aspect;
        let ddx=lx+rx*nx*tanFov+ux*ny*tanFov;
        let ddy=ly+ry*nx*tanFov+uy*ny*tanFov;
        let ddz=lz+rz*nx*tanFov+uz*ny*tanFov;
        const dd=Math.sqrt(ddx*ddx+ddy*ddy+ddz*ddz);
        ddx/=dd; ddy/=dd; ddz/=dd;

        const hit=traceRay(camX,camY,camZ,ddx,ddy,ddz,p);
        let packed=0;
        if      (hit.hit==='bh')   packed=0;
        else if (hit.hit==='disk') packed=diskPacked(hit.r,hit.phi,hit.near,p);
        else                       packed=skyPacked(hit.az,hit.el,p);

        const idx=(py*pw+px)*4;
        data[idx]  =(packed>>16)&0xff;
        data[idx+1]=(packed>>8)&0xff;
        data[idx+2]= packed&0xff;
        data[idx+3]=255;
      }
    }

    const pct=Math.min(100,Math.round(((r0+chunk)/ph)*100));
    g('pf').style.width=pct+'%';
    g('status-text').textContent=`RENDERING — ${pct}%`;
    offCtx.putImageData(imgData,0,0);
    ctx.clearRect(0,0,W,H);
    ctx.drawImage(offscr,0,0,W,H);
    await new Promise(r=>setTimeout(r,0));
  }

  offCtx.putImageData(imgData,0,0);
  ctx.clearRect(0,0,W,H);
  ctx.drawImage(offscr,0,0,W,H);

  // Post-process bloom
  drawBloom(p, camX, camY, camR, pw, ph);

  g('pf').style.width='100%';
  g('status-text').textContent=`COMPLETE  ·  ${pw}×${ph}  ·  ${p.steps} STEPS/RAY`;
  btn.textContent='▶  RENDER';
  btn.classList.remove('rendering');
  rendering=false;
}

// ── Randomize ─────────────────────────────────────────────────────
function randomize() {
  const set=(id,v)=>{g(id).value=v;g(id).dispatchEvent(new Event('input'));};
  set('sm',  (0.4+Math.random()*2.5).toFixed(2));
  set('sd',  (10+Math.random()*45).toFixed(1));
  set('si',  Math.floor(5+Math.random()*84));
  set('sf',  Math.floor(25+Math.random()*80));
  set('sri', (3+Math.random()*7).toFixed(2));
  set('sro', (12+Math.random()*28).toFixed(1));
  set('sbr', (0.5+Math.random()*3.5).toFixed(1));
  startRender();
}

// ── Boot ──────────────────────────────────────────────────────────
window.addEventListener('load', ()=>{ resize(); startRender(); });
</script>
</body>
</html>
